options {
    DEBUG_TOKEN_MANAGER = false;
	DEBUG_PARSER= false;
	DEBUG_LOOKAHEAD=false;
}

PARSER_BEGIN(Compilateur)
import java.io.InputStream;
import AST.*;
import java.io.FileWriter;
import java.io.IOException;
import java.util.List;
import java.util.ArrayList;
import java.io.StringReader;  
import java.util.Scanner;
 

public class Compilateur {
private String input;


public Compilateur(String input) {
this.input = input;
ReInit(new java.io.StringReader(input));
}


public static void main(String args[]) {
    try {
        Scanner scanner = new Scanner(System.in);
        String input = scanner.nextLine();
        scanner.close();
        Compilateur parseur = new Compilateur(input);
        List<Expr_Pt_Virg> commands = parseur.mainNT();
        String nameFile;
        
        try {
            nameFile = args.length == 0 ? "malib.jsm" : args[0] + ".jsm";
            FileWriter f = new FileWriter(nameFile, false);
            
            try {
                for (int i = 0; i < commands.size(); i++) {
                    boolean isLast = (i == commands.size() - 1);
                   f.write(commands.get(i).toAssembly(isLast));
                }
            } finally {
                f.close();
            }
            
            for (int i = 0; i < commands.size(); i++) {
                boolean isLast = (i == commands.size() - 1);
                System.out.print(commands.get(i).toAssembly(isLast));
            }
            
            System.out.println("C'est bien une expression arithmetique");
            
        } catch (IOException e) {
            System.err.println("Erreur d'Ã©criture fichier:");
            e.printStackTrace();
        }
        
    } catch (TokenMgrError e) {
        System.out.println("Ceci n'est pas une expression arithmetique");
    } catch (ParseException e) {
        System.out.println("Ceci n'est pas une expression arithmetique");
    }
}
}

PARSER_END(Compilateur)
 
SKIP :
{ " " | "\t" | "\r"}
TOKEN :
{ < NUMBER: ((["1"-"9"] (["0"-"9"])* | "0") ("."(["0"-"9"])*)?)
    | (((["0"-"9"])+ ("." (["0"-"9"])+)? | "." (["0"-"9"])+) ("e") (["-"])? (["0"-"9"])+)
    |  ("NaN") >
| < PV : ";" >
| <BOOLEAN : ("True" | "False")>  
| <IMPORT: "import" >
| <Equals: "==">
| <NotEql: "!=">
| <LoEqlNb : "<=" >
| <GrEqlNb : ">=" >
| <LoStlNb : "<" >
| <GrStlNb : ">" >
| <Not : "!" >
|< IDENTIFIER: (["a"-"z", "A"-"Z", "_"])(["a"-"z", "A"-"Z", "0"-"9", "_"])* >
}
 
Expr_Pt_Virg importCommand():
{Token t;}
{  <IMPORT> t=<IDENTIFIER>    <PV> 
{
    return new Expr_Pt_Virg("import "+ t.image);
} } 
 
List<Expr_Pt_Virg> mainNT() :
{
    List<Expr_Pt_Virg> commands = new ArrayList<>();
    Expr_Pt_Virg e;
}
{
    (e=importCommand() {commands.add(e); })*
    (e=command() { commands.add(e); })+  
    { return commands; }             
}
 
 

Expr_Pt_Virg command():
{ExpressionA e;
}
{
       e=comparaison() <PV> { return new Expr_Pt_Virg(e); }
}
 


 

ExpressionA comparaison():
{ExpressionA e;
ExpressionA res;}
{
e = expression() { res = e; } (
    <Equals>   e = expression() { res = new Equals(res, e); }
  | <NotEql>   e = expression() { res = new NotEquals(res, e); }
  | <LoEqlNb>  e = expression() { res = new LessOrEqual(res, e); }
  | <GrEqlNb>  e = expression() { res = new GreaterOrEqual(res, e); }
  | <LoStlNb>  e = expression() { res = new LessThen(res, e); }
  | <GrStlNb>  e = expression() { res = new GreaterThen(res, e); }
)* { return res; }
}




ExpressionA expression () :
{ExpressionA e;
ExpressionA res;}
{ e=terme() {res=e;}( 
"+" e=terme() {res=new Plus(res,e);}
| "-" e=terme() {res=new Moins(res,e);}
)* {return res;}
}

ExpressionA terme () :
{ExpressionA res;
ExpressionA e;}
{ e=facteur() {res=e;}(
"*" e=facteur() {res=new Mult(res,e);}
|"/" e=facteur() {res=new Div(res,e);}
)* {return res;}
 
}
 
 


ExpressionA facteur () :
{ExpressionA e;
Token t;}
{ "(" e=comparaison() ")" {return e;}
| "-" e=facteur() {return new Neg(e);}
| <Not> e=facteur() {return new Not(e);}
| t=<NUMBER>  {return new Num(Double.parseDouble(t.image));}
| t=<BOOLEAN>  {return new Bool(Boolean.parseBoolean(t.image));}
}



 
 
 